from typing import Any, Dict, Hashable, List, Optional, Set, Tuple, TypeVar

from computedfields.helper import is_sublist as is_sublist
from computedfields.helper import modelname as modelname
from computedfields.helper import pairwise as pairwise
from computedfields.helper import parent_to_inherited_path as parent_to_inherited_path
from computedfields.helper import skip_equal_segments as skip_equal_segments
from django.db.models import Model

from graphviz import Digraph

class ComputedFieldsException(Exception): ...
class CycleException(ComputedFieldsException): ...
class CycleEdgeException(CycleException): ...
class CycleNodeException(CycleException): ...

class Edge:
    instances: Dict[Tuple[Hashable, Hashable], "Edge"] = ...
    def __new__(cls, *args: Tuple[Hashable, Hashable, Dict[str, str]]) -> "Edge": ...
    left: Hashable = ...
    right: Hashable = ...
    data: Dict[str, str] = ...
    def __init__(
        self, left: Hashable, right: Hashable, data: Optional[Dict[str, str]] = ...
    ) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class Node:
    instances: Dict[Hashable, "Node"] = ...
    def __new__(cls, *args: Dict[str, str]) -> "Node": ...
    data: Dict[str, str] = ...
    def __init__(self, data: Dict[str, str]) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class Graph:
    nodes: Set[Node] = ...
    edges: Set[Edge] = ...
    def __init__(self) -> None: ...
    def add_node(self, node: Node) -> None: ...
    def remove_node(self, node: Node) -> None: ...
    def add_edge(self, edge: Edge) -> None: ...
    def remove_edge(self, edge: Edge) -> None: ...
    def get_dot(
        self,
        format: str = ...,
        mark_edges: Optional[Dict[Edge, Dict[str, str]]] = ...,
        mark_nodes: Optional[Dict[Node, Dict[str, str]]] = ...,
    ) -> Digraph: ...
    def render(
        self,
        filename: Optional[str] = ...,
        format: str = ...,
        mark_edges: Optional[Dict[Edge, Dict[str, str]]] = ...,
        mark_nodes: Optional[Dict[Node, Dict[str, str]]] = ...,
    ) -> None: ...
    def view(
        self,
        format: str = ...,
        mark_edges: Optional[Dict[Edge, Dict[str, str]]] = ...,
        mark_nodes: Optional[Dict[Node, Dict[str, str]]] = ...,
    ) -> None: ...
    def edgepath_to_nodepath(self, path: List[Edge]) -> List[Node]: ...
    def nodepath_to_edgepath(self, path: List[Node]) -> List[Edge]: ...
    def get_edgepaths(self) -> List[Edge]: ...
    def get_nodepaths(self) -> List[Node]: ...
    def get_cycles(self) -> Dict[Hashable, Any]: ...
    @property
    def edge_cycles(self) -> List[List[Edge]]: ...
    @property
    def node_cycles(self) -> List[List[Node]]: ...
    @property
    def is_cyclefree(self) -> bool: ...
    def remove_redundant(self) -> Set[Edge]: ...

class ComputedModelsGraph(Graph):
    models: Dict[str, str] = ...
    resolved: Dict[str, Any] = ...
    cleaned_data: Any = ...
    modelgraphs: Dict[str, "ModelGraph"] = ...
    union: Optional[Graph] = ...
    def __init__(self, computed_models: Dict[str, List[str]]) -> None: ...
    def resolve_dependencies(
        self, computed_models: Dict[str, List[str]]
    ) -> Dict[str, Any]: ...
    def generate_lookup_map(self) -> Dict[str, Dict[str, Any]]: ...
    def prepare_modelgraphs(self) -> None: ...
    def generate_local_mro_map(self) -> Dict[str, Dict[str, Any]]: ...
    def get_uniongraph(self) -> Graph: ...

class ModelGraph(Graph):
    model: Model = ...
    def __init__(
        self,
        model: Model,
        local_dependencies: Dict[str, List[str]],
        computed_fields: List[str],
    ) -> None: ...
    def transitive_reduction(self) -> None: ...
    def get_topological_paths(self) -> Dict[Node, List[Node]]: ...
    def generate_field_paths(
        self, tpaths: Dict[Node, List[Node]]
    ) -> Dict[Any, List[Any]]: ...
    def generate_local_mapping(
        self, field_paths: Dict[str, List[str]]
    ) -> Dict[str, Any]: ...
